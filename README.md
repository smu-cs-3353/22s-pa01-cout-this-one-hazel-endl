# PA 01: The Art Gallery
London Kasper and Hazel Eroy
### Summary
For this program, we were tasked with finding the optimal set of paintings to place on an art gallery’s wall. Given a dataset with each painting’s price, width and other identifying information, we needed to find the best possible combination of paintings to represent the highest cumulative price on the wall while fitting the space constraints we were given. In order to do this, we developed three algorithms: a brute force algorithm, a most-expensive first algorithm, and a custom algorithm of our own design.
### Usage
This program takes an input file of paintings and finds the best combination of paintings to optimize for highest total price on the wall. Example input file:
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/1.png)
<br>Given the above input file, the program will run the data through three different algorithms to find the best combination from each method. The first line is the total price of the selected paintings, and each line after represents a painting’s information in the format “id/price/width/height.” Example brute force output file:
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/2.png)
<br>Example most-expensive first output file:
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/3.png)
<br>Example custom algorithm output file:
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/4.png)
<br>As you can see from these outputs, the brute force algorithm produces the optimal solution with the custom algorithm following close behind. However, the input dataset only includes 10 paintings, and our brute force algorithm loses efficiency as that number increases.

### Building and Executing
In order to build and execute this program, follow the following steps in your terminal:
<br>1. Navigate to the src folder in the program folder using cd (ex: cd Full/Path/To/Program)
<br>2. Use the following command to compile each .cpp file in the src folder: g++ main.cpp algorithm.cpp subset.cpp painting.cpp
<br>3. Create an executable using the resulting .o files from step 2: g++ -o program main.o algorithm.o subset.o painting.o
<br>4. Using the .exe created through compilation, run the program with your desired input file: (ex: ./program ../your/input/file)
### Brute Force Algorithm:
The brute force algorithm’s goal is to find the most profitable painting combination, regardless of computing time. It starts by finding all possible combinations of paintings that fit on a wall. As each combination is created, the total painting width is compared to the wall’s width. If the total painting width is shorter than the wall, then it is added into a vector of subset objects, otherwise it is discarded. Once the vector is filled, we use a totalPrice function to find the total price of the painting combinations. Once all those are found, there is logic to traverse through the vector to find the most expensive total price. This logic finds all possible subsets in a dataset and has to traverse a vector, this algorithm ultimately yields the worst results in regards to computation time but outputs the optimal total price.
<br><br>As mentioned before, the brute force algorithm takes the longest to run due to its extensive process. We attempted to make this process less strenuous by adding an additional check to see if a subset would even be a viable wall option as it was created. Since brute force checks every single possible combination of paintings, it will eventually start creating subsets with sizes approaching that of the input data. While this may be a reasonable option for small data sets, as the size of the input data grows it becomes far less likely to be a possibility. This is displayed in the below graph, which shows that as the data set size grows, the brute force algorithm takes exponentially longer to run. That is directly tied to the algorithm, as a brute force algorithm needs to check every single subset, the number of which is defined by an exponential function (2^size).
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/5.png)
<br>
### Most-Expensive First Algorithm:
Our most-expensive first algorithm was meant to prioritize paintings by price alone. We sorted our vector of Painting objects by their prices, descending from most expensive at the front of our vector to least expensive at the end. From here, we started adding the most expensive paintings to a new vector until the sum of their widths was as large as it could be within the constraints of our dataset and the given width of the wall.
<br><br>Due to the nature of this algorithm, its results in regard to price-to-width efficiency were suboptimal. Our most-expensive first algorithm generally had the lowest total price, especially as the size of our datasets increased. For example, in our sample output shown in the “Usage” section of this paper, the most-expensive first algorithm only outputted a single painting as being the ‘best’ subset. That is due to the fact that that painting was the most expensive of the set, and also happened to be the widest. There were no other paintings that were able to be combined with it while fitting the 1024 unit wide constraint. However, the total price of that single painting was far less than the total price of the subsets generated by our custom and brute force algorithms. The ‘success’ of this algorithm is purely based on the data it is given.
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/6.png)
<br>
### Custom Algorithm:
In order for our custom algorithm to be worth using, it needed to be more time-efficient than our brute force algorithm while producing a better output than the most-expensive first algorithm. To accomplish this, we added a new attribute to our Painting object, PriceByWidth, that stores each painting’s price to width ratio when a new Painting object is constructed. For example, if a painting takes up 10 units but is worth $1000, its PriceByWidth ratio is $10 per unit. However, if a painting only takes up 5 units and also costs $1000, its PriceByWidth ratio is $20 and is therefore a better display option. Using the same logic as the most-expensive algorithm, we sorted the full vector of painting options by their PriceByWidth ratio from greatest to least. We then iterated through the vector, adding paintings to the bestRatio vector until we no longer had space to add any more paintings from our dataset.
<br><br>Our custom algorithm was very simple, but yielded great results. The total price of the paintings on the wall for this algorithm was consistently higher than that of the most-expensive first algorithm, and our custom algorithm often used up more space on the wall while producing significantly higher outputs. The structure of this algorithm allowed us to use the space we were given more efficiently. The results of our custom algorithm were comparable to that of the brute force algorithm, and the algorithm takes much less time to execute. Overall, we were very pleased with how our custom algorithm turned out. 
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/8.png)
<br>![](https://raw.githubusercontent.com/smu-cs-3353/22s-pa01-cout-this-one-hazel-endl/main/image/7.png)
